// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'siol_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

SoilType _$SoilTypeFromJson(Map<String, dynamic> json) {
  return _SoilType.fromJson(json);
}

/// @nodoc
mixin _$SoilType {
  int get soilTypeId => throw _privateConstructorUsedError;
  String get soilTypeName => throw _privateConstructorUsedError;
  int? get tawInMm => throw _privateConstructorUsedError;
  int? get fcPercent => throw _privateConstructorUsedError;
  int? get wpPercent => throw _privateConstructorUsedError;
  int? get sPercent => throw _privateConstructorUsedError;
  double? get bulkDensity => throw _privateConstructorUsedError;
  int? get cec => throw _privateConstructorUsedError;
  String? get updatedDate => throw _privateConstructorUsedError;
  bool? get isActive => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SoilTypeCopyWith<SoilType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SoilTypeCopyWith<$Res> {
  factory $SoilTypeCopyWith(SoilType value, $Res Function(SoilType) then) =
      _$SoilTypeCopyWithImpl<$Res, SoilType>;
  @useResult
  $Res call(
      {int soilTypeId,
      String soilTypeName,
      int? tawInMm,
      int? fcPercent,
      int? wpPercent,
      int? sPercent,
      double? bulkDensity,
      int? cec,
      String? updatedDate,
      bool? isActive});
}

/// @nodoc
class _$SoilTypeCopyWithImpl<$Res, $Val extends SoilType>
    implements $SoilTypeCopyWith<$Res> {
  _$SoilTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? soilTypeId = null,
    Object? soilTypeName = null,
    Object? tawInMm = freezed,
    Object? fcPercent = freezed,
    Object? wpPercent = freezed,
    Object? sPercent = freezed,
    Object? bulkDensity = freezed,
    Object? cec = freezed,
    Object? updatedDate = freezed,
    Object? isActive = freezed,
  }) {
    return _then(_value.copyWith(
      soilTypeId: null == soilTypeId
          ? _value.soilTypeId
          : soilTypeId // ignore: cast_nullable_to_non_nullable
              as int,
      soilTypeName: null == soilTypeName
          ? _value.soilTypeName
          : soilTypeName // ignore: cast_nullable_to_non_nullable
              as String,
      tawInMm: freezed == tawInMm
          ? _value.tawInMm
          : tawInMm // ignore: cast_nullable_to_non_nullable
              as int?,
      fcPercent: freezed == fcPercent
          ? _value.fcPercent
          : fcPercent // ignore: cast_nullable_to_non_nullable
              as int?,
      wpPercent: freezed == wpPercent
          ? _value.wpPercent
          : wpPercent // ignore: cast_nullable_to_non_nullable
              as int?,
      sPercent: freezed == sPercent
          ? _value.sPercent
          : sPercent // ignore: cast_nullable_to_non_nullable
              as int?,
      bulkDensity: freezed == bulkDensity
          ? _value.bulkDensity
          : bulkDensity // ignore: cast_nullable_to_non_nullable
              as double?,
      cec: freezed == cec
          ? _value.cec
          : cec // ignore: cast_nullable_to_non_nullable
              as int?,
      updatedDate: freezed == updatedDate
          ? _value.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as String?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SoilTypeCopyWith<$Res> implements $SoilTypeCopyWith<$Res> {
  factory _$$_SoilTypeCopyWith(
          _$_SoilType value, $Res Function(_$_SoilType) then) =
      __$$_SoilTypeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int soilTypeId,
      String soilTypeName,
      int? tawInMm,
      int? fcPercent,
      int? wpPercent,
      int? sPercent,
      double? bulkDensity,
      int? cec,
      String? updatedDate,
      bool? isActive});
}

/// @nodoc
class __$$_SoilTypeCopyWithImpl<$Res>
    extends _$SoilTypeCopyWithImpl<$Res, _$_SoilType>
    implements _$$_SoilTypeCopyWith<$Res> {
  __$$_SoilTypeCopyWithImpl(
      _$_SoilType _value, $Res Function(_$_SoilType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? soilTypeId = null,
    Object? soilTypeName = null,
    Object? tawInMm = freezed,
    Object? fcPercent = freezed,
    Object? wpPercent = freezed,
    Object? sPercent = freezed,
    Object? bulkDensity = freezed,
    Object? cec = freezed,
    Object? updatedDate = freezed,
    Object? isActive = freezed,
  }) {
    return _then(_$_SoilType(
      soilTypeId: null == soilTypeId
          ? _value.soilTypeId
          : soilTypeId // ignore: cast_nullable_to_non_nullable
              as int,
      soilTypeName: null == soilTypeName
          ? _value.soilTypeName
          : soilTypeName // ignore: cast_nullable_to_non_nullable
              as String,
      tawInMm: freezed == tawInMm
          ? _value.tawInMm
          : tawInMm // ignore: cast_nullable_to_non_nullable
              as int?,
      fcPercent: freezed == fcPercent
          ? _value.fcPercent
          : fcPercent // ignore: cast_nullable_to_non_nullable
              as int?,
      wpPercent: freezed == wpPercent
          ? _value.wpPercent
          : wpPercent // ignore: cast_nullable_to_non_nullable
              as int?,
      sPercent: freezed == sPercent
          ? _value.sPercent
          : sPercent // ignore: cast_nullable_to_non_nullable
              as int?,
      bulkDensity: freezed == bulkDensity
          ? _value.bulkDensity
          : bulkDensity // ignore: cast_nullable_to_non_nullable
              as double?,
      cec: freezed == cec
          ? _value.cec
          : cec // ignore: cast_nullable_to_non_nullable
              as int?,
      updatedDate: freezed == updatedDate
          ? _value.updatedDate
          : updatedDate // ignore: cast_nullable_to_non_nullable
              as String?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SoilType with DiagnosticableTreeMixin implements _SoilType {
  const _$_SoilType(
      {required this.soilTypeId,
      required this.soilTypeName,
      this.tawInMm,
      this.fcPercent,
      this.wpPercent,
      this.sPercent,
      this.bulkDensity,
      this.cec,
      this.updatedDate,
      this.isActive});

  factory _$_SoilType.fromJson(Map<String, dynamic> json) =>
      _$$_SoilTypeFromJson(json);

  @override
  final int soilTypeId;
  @override
  final String soilTypeName;
  @override
  final int? tawInMm;
  @override
  final int? fcPercent;
  @override
  final int? wpPercent;
  @override
  final int? sPercent;
  @override
  final double? bulkDensity;
  @override
  final int? cec;
  @override
  final String? updatedDate;
  @override
  final bool? isActive;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SoilType(soilTypeId: $soilTypeId, soilTypeName: $soilTypeName, tawInMm: $tawInMm, fcPercent: $fcPercent, wpPercent: $wpPercent, sPercent: $sPercent, bulkDensity: $bulkDensity, cec: $cec, updatedDate: $updatedDate, isActive: $isActive)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SoilType'))
      ..add(DiagnosticsProperty('soilTypeId', soilTypeId))
      ..add(DiagnosticsProperty('soilTypeName', soilTypeName))
      ..add(DiagnosticsProperty('tawInMm', tawInMm))
      ..add(DiagnosticsProperty('fcPercent', fcPercent))
      ..add(DiagnosticsProperty('wpPercent', wpPercent))
      ..add(DiagnosticsProperty('sPercent', sPercent))
      ..add(DiagnosticsProperty('bulkDensity', bulkDensity))
      ..add(DiagnosticsProperty('cec', cec))
      ..add(DiagnosticsProperty('updatedDate', updatedDate))
      ..add(DiagnosticsProperty('isActive', isActive));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SoilType &&
            (identical(other.soilTypeId, soilTypeId) ||
                other.soilTypeId == soilTypeId) &&
            (identical(other.soilTypeName, soilTypeName) ||
                other.soilTypeName == soilTypeName) &&
            (identical(other.tawInMm, tawInMm) || other.tawInMm == tawInMm) &&
            (identical(other.fcPercent, fcPercent) ||
                other.fcPercent == fcPercent) &&
            (identical(other.wpPercent, wpPercent) ||
                other.wpPercent == wpPercent) &&
            (identical(other.sPercent, sPercent) ||
                other.sPercent == sPercent) &&
            (identical(other.bulkDensity, bulkDensity) ||
                other.bulkDensity == bulkDensity) &&
            (identical(other.cec, cec) || other.cec == cec) &&
            (identical(other.updatedDate, updatedDate) ||
                other.updatedDate == updatedDate) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      soilTypeId,
      soilTypeName,
      tawInMm,
      fcPercent,
      wpPercent,
      sPercent,
      bulkDensity,
      cec,
      updatedDate,
      isActive);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SoilTypeCopyWith<_$_SoilType> get copyWith =>
      __$$_SoilTypeCopyWithImpl<_$_SoilType>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SoilTypeToJson(
      this,
    );
  }
}

abstract class _SoilType implements SoilType {
  const factory _SoilType(
      {required final int soilTypeId,
      required final String soilTypeName,
      final int? tawInMm,
      final int? fcPercent,
      final int? wpPercent,
      final int? sPercent,
      final double? bulkDensity,
      final int? cec,
      final String? updatedDate,
      final bool? isActive}) = _$_SoilType;

  factory _SoilType.fromJson(Map<String, dynamic> json) = _$_SoilType.fromJson;

  @override
  int get soilTypeId;
  @override
  String get soilTypeName;
  @override
  int? get tawInMm;
  @override
  int? get fcPercent;
  @override
  int? get wpPercent;
  @override
  int? get sPercent;
  @override
  double? get bulkDensity;
  @override
  int? get cec;
  @override
  String? get updatedDate;
  @override
  bool? get isActive;
  @override
  @JsonKey(ignore: true)
  _$$_SoilTypeCopyWith<_$_SoilType> get copyWith =>
      throw _privateConstructorUsedError;
}
